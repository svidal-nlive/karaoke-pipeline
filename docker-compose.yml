# Root-level docker-compose.yml for Karaoke Pipeline
# Supports bind-mount or named-volume modes via profiles

version: "3.9"
services:
  redis:
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - redis_data:/data
    networks: [backend]

  volume-init:
    build:
      context: ./volume-init
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "0:0"
    command: []
    volumes:
      # Always reference /input, /queue, etc; profiles swap bind/named volumes
      - input:/input
      - queue:/queue
      - logs:/logs
      - metadata:/metadata
      - output:/output
      - organized:/organized
      - stems:/stems
    networks: [backend]
    restart: "no"

  watcher:
    build: ./watcher
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}
      LOG_LEVEL: ${LOG_LEVEL}
    volumes:
      - input:/input
      - queue:/queue
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  metadata:
    build: ./metadata
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - queue:/queue
      - metadata:/metadata
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  splitter:
    build: ./splitter
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      CHUNKING_ENABLED: ${CHUNKING_ENABLED}
      CHUNK_LENGTH_MS: ${CHUNK_LENGTH_MS}
      SPLITTER_TYPE: ${SPLITTER_TYPE}
      STEMS: ${STEMS}
      STEM_TYPE: ${STEM_TYPE}
    volumes:
      - queue:/queue
      - stems:/stems
      - logs:/logs
      - ./temp_chunks:/tmp
      - ./models:/app/pretrained_models
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  packager:
    build: ./packager
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - stems:/stems
      - metadata:/metadata
      - output:/output
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  organizer:
    build: ./organizer
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - output:/output
      - organized:/organized
      - metadata:/metadata
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  status-api:
    build: ./status-api
    args:
      PUID: ${PUID}
      PGID: ${PGID}
    user: "${PUID}:${PGID}"
    ports:
      - "5001:5001"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - input:/input
      - queue:/queue
      - metadata:/metadata
      - output:/output
      - organized:/organized
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  dashboard:
    build: ./dashboard/karaoke-pipeline-dashboard
    ports:
      - "3001:80"
    environment:
      - REACT_APP_STATUS_API_URL=http://status-api:5001
    depends_on:
      - status-api
    networks: [backend]

# ----------- Volume and Profile Definitions -------------
volumes:
  # Default: named volumes for all pipeline shared dirs
  input:
    name: input
  queue:
    name: queue
  stems:
    name: stems
  output:
    name: output
  organized:
    name: organized
  metadata:
    name: metadata
  logs:
    name: logs
  redis_data:
    name: redis_data

# Profiles for bind-mounts instead of named volumes
# To use: `docker compose --profile bind up`
profiles:
  bind:
    # Only affects volume definitions; all services use the same mount points
    volumes:
      input:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/input
          o: bind
      queue:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/queue
          o: bind
      stems:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/stems
          o: bind
      output:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/output
          o: bind
      organized:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/organized
          o: bind
      metadata:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/metadata
          o: bind
      logs:
        driver: local
        driver_opts:
          type: none
          device: ${PWD}/pipeline-data/logs
          o: bind
    # Redis always named

networks:
  backend:
    driver: bridge
