# Root-level docker-compose.yml for Karaoke Pipeline
# Default: named volumes for pipeline-data

services:
  redis:
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - redis_data:/data
    networks: [backend]

  volume-init:
    build:
      context: ./volume-init
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "0:0"
    command: []
    volumes:
      - input:/input
      - queue:/queue
      - logs:/logs
      - metadata:/metadata
      - output:/output
      - organized:/organized
      - stems:/stems
    networks: [backend]
    restart: "no"

  watcher:
    build:
      context: .
      dockerfile: watcher/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}
      LOG_LEVEL: ${LOG_LEVEL}
    volumes:
      - input:/input
      - queue:/queue
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  metadata:
    build:
      context: .
      dockerfile: metadata/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - queue:/queue
      - metadata:/metadata
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  splitter:
    build:
      context: .
      dockerfile: splitter/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      CHUNKING_ENABLED: ${CHUNKING_ENABLED}
      CHUNK_LENGTH_MS: ${CHUNK_LENGTH_MS}
      SPLITTER_TYPE: ${SPLITTER_TYPE}
      STEMS: ${STEMS}
      STEM_TYPE: ${STEM_TYPE}
    volumes:
      - queue:/queue
      - stems:/stems
      - logs:/logs
      - ./temp_chunks:/tmp
      - ./models:/app/pretrained_models
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  packager:
    build:
      context: .
      dockerfile: packager/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      STEMS_DIR: /stems
      PACKAGED_DIR: /output
    volumes:
      - stems:/stems
      - metadata:/metadata
      - output:/output
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  organizer:
    build:
      context: .
      dockerfile: organizer/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - output:/output
      - organized:/organized
      - metadata:/metadata
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  status-api:
    build:
      context: .
      dockerfile: status-api/Dockerfile
      args:
        PUID: ${PUID}
        PGID: ${PGID}
    user: "${PUID}:${PGID}"
    ports:
      - "5001:5001"
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
    volumes:
      - input:/input
      - queue:/queue
      - metadata:/metadata
      - output:/output
      - organized:/organized
      - logs:/logs
    depends_on:
      volume-init:
        condition: service_completed_successfully
      redis:
        condition: service_started
    networks: [backend]

  dashboard:
    build:
      context: ./dashboard/karaoke-dashboard
    ports:
      - "3002:3000"  # Change host port as needed
    # volumes:
    command: npm run dev -- --hostname 0.0.0.0 --port 3000
    networks: [backend]
    environment:
      - NODE_ENV=development

  tunnel:
    container_name: karaoke-pipeline-tunnel
    image: cloudflare/cloudflared
    restart: unless-stopped
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=${TUNNEL_TOKEN}
    networks: [backend]

volumes:
  input:
  queue:
  stems:
  output:
  organized:
  metadata:
  logs:
  redis_data:

networks:
  backend:
    driver: bridge
